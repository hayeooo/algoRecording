package algo_2023_08_30;
/*
 * BOJ 1600: 말이 되고픈 원숭이
 * 현 위치에서 갈 수 있는 모든 방향에 대해 이동한다.
 * 1. 인접한 네 방향 2. 말의 움직임
 * 장애물은 피해야 하고 이미 방문한 칸은 방문 표시를 해야한다.
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class BOJ_1600_말이되고픈원숭이_김하연 {

	static BufferedReader br;
	static StringTokenizer st;
	
	static int K;				// 말 움직임 횟수
	static int W, H;			// 격자판의 가로, 세로 길이
	static int[][] board;		// 격자판 정보
	
	static int[] dx= {-1,0,1,0};	// 북, 동, 남, 서
	static int[] dy= {0,1,0,-1};
	static int[] horseDx= {-1,-2,-2,-1,1,2,2,1};
	static int[] horseDy= {-2,-1,2,3,3,1,-1,-2};
	static boolean[][] visited;
	static int minCnt;
	public static void main(String[] args) throws NumberFormatException, IOException {
		
		br=new BufferedReader(new InputStreamReader(System.in));
		
		// 말 움직임 횟수 입력 받는다.
		K=Integer.parseInt(br.readLine().trim());
		
		// 격자판의 가로, 세로 길이를 입력 받는다.
		st=new StringTokenizer(br.readLine().trim());
		W=Integer.parseInt(st.nextToken());
		H=Integer.parseInt(st.nextToken());
		
		// 격자판 정보를 입력 받는다.
		board=new int[H][W];
		visited=new boolean[H][W];
		minCnt=Integer.MAX_VALUE;
		visited[0][0]=true;

	}
	// 현재 위치에서 갈 수 있는 모든 방향에 대해 탐색한다.
	// 원숭이가 움직인 횟수(cnt)와 말의 움직임으로 갈 수 있는 횟수(chance)
	public static void dfs(int x,int y,int chance,int cnt) {
		// 도착 지점에 도착한 경우
		if (x==H-1 && y==W-1) {
			minCnt=Math.min(minCnt, cnt);
			return;
		}
		// 인접한 칸으로 이동하는 경우
		for (int d=0;d<dx.length;d++) {
			int nextX=x+dx[d];
			int nextY=y+dy[d];
			
			// 배열의 범위를 넘어간 경우
			if (nextX<0 || nextX>=H || nextY<0 || nextY>=W) continue;
			
			// 장애물인 경우
			if (board[nextX][nextY]==1) continue;
			
			// 모두 해당되지 않은 경우
			// 다음 칸으로 이동할 수 있다.
			visited[nextX][nextY]=true;
			dfs(nextX,nextY,chance,cnt+1);
			visited[nextX][nextY]=false;
			
		}
		
		// 말의 움직임으로 이동하는 경우
		// 말 움직임 횟수가 남아있을 때
		if (chance>0) {
			for (int d=0;d<horseDx.length;d++) {
				
			}
		}
	}

}
