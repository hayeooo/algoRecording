package algo_2023_09_01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/*
 * BOJ 2468: 안전 영역
 * 어떤 지역의 높이 정보를 파악하여 그 지역에 많은 비가 내렸을 때
 * 물에 잠기지 않는 안전한 영역이 최대로 몇 개가 만들어 지는 지를 조사한다.
 * 안전한 영역은 물에 잠기지 않는 지점들의 위, 아래, 오른쪽, 왼쪽으로 인접해있으며 그 크기가 최대인 영역이다.
 * 
 * 1. 지역의 정보를 입력받는다.
 * 2. 잠길 수 있는 모든 높이에 대해 안전한 영역 개수를 구한다.
 * 3. 높이가 >=N 인 지역에 대해 bfs를 수행한다.
 * 	3-1. 이미 방문한 지역에 중복으로 가지 않기 위해 방문 여부 정보를 담는 배열을 만든다.
 * 4. 가능한 모든 높이에 대해 bfs를 수행하였을 때, 안전한 영역의 최댓값을 저장한다.
 */
public class BOJ_2468_안전영역_김하연 {
	static BufferedReader br;
	static StringTokenizer st;
	
	static int N;				// 2차원 배열의 행과 열의 개수
	static int[][] map;			// 어떤 지역들의 높이를 저장하는 배열
	static boolean[][] visited;
	public static void main(String[] args) throws NumberFormatException, IOException {
		
		br=new BufferedReader(new InputStreamReader(System.in));
		
		// 2차원 배열의 행과 열의 개수를 입력받는다.
		N=Integer.parseInt(br.readLine());
		
		int minHeight=Integer.MAX_VALUE;
		int maxHeight=0;
		
		// 2차원 배열 높이 정보를 입력받는다.
		for (int row=0;row<N;row++) {
			st=new StringTokenizer(br.readLine().trim());
			for (int col=0;col<N;col++) {
				map[row][col]=Integer.parseInt(st.nextToken());
				
				// 가능한 높이의 범위를 구한다.
				minHeight=Math.min(minHeight, map[row][col]);
				maxHeight=Math.min(maxHeight, map[row][col]);
			}
		}
		
		// 잠길 높이를 구한다.
		for (int height=minHeight;height<=maxHeight;height++) {
			// 잠길 높이가 구해졌다면
			// 잠길 높이보다 높은 지역에 대한 bfs를 수행한다.
			int safeRegion=0;
			visited=new boolean[N][N];
			for (int row=0;row<N;row++) {
				for (int col=0;col<N;col++) {
					if (map[row][col]>height && )
				}
			}
		}
	

	}

}
